// AUTO-GENERATED by tools/gen_headers.py (M16 SSOT pipeline)
// source: include/SramMap.h
// DO NOT EDIT THIS FILE MANUALLY.

// SramMap.h
#pragma once
#include <cstdint>
#include "gen/ModelShapes.h"

// ============================================================
// SramMap.h (WORD addressing / u32 addr_word)
// ------------------------------------------------------------
// - All addresses/sizes are in u32 words (1 word = 4 bytes).
// - Alignment is defined in words.
//
// v11.5 update (方案 1 / M2-2P):
// - "Logical regions" are still fixed to 4 contention classes:
//     * X_PAGE0, X_PAGE1, SCRATCH, W_REGION
// - Physical implementation MAY be a single true 2-port SRAM macro.
//   (Top arbitrates and schedules up to 2 accesses/cycle, one per port.)
// - Therefore, this header uses ONE flat addr_word space; there is NO bank index here.
//
// Notes:
// - This map matches:
//     * X ping-pong (X_PAGE0 / X_PAGE1)
//     * SCRATCH S1: KV cache (SCR_K + SCR_V)
//     * No dedicated DEBUG region (D1 debug is "halt + READ_MEM")
//     * [legacy] Separate BIAS/WEIGHT regions kept for backward compatibility,
//       while v11.4+ uses SET_W_BASE + unified PARAM stream.
// ============================================================

static const uint32_t ALIGN_WORDS = 16; // 64B alignment (16 words * 4B)
static_assert((ALIGN_WORDS % W_LANES) == 0, "ALIGN_WORDS must be a multiple of W_LANES");

constexpr uint32_t align_up_words(uint32_t x, uint32_t a) {
  return ((x + a - 1u) / a) * a;
}

namespace sram_map {

// ------------------------------------------------------------
// Logical regions (contention classes)
// ------------------------------------------------------------
enum SramRegion : uint8_t {
  REG_X_PAGE0 = 0,
  REG_X_PAGE1 = 1,
  REG_SCRATCH = 2,
  REG_W_REGION = 3,
  REG_INVALID = 255
};

// ----------------------------
// X ping-pong
// ----------------------------
// X is fp32 [N_NODES, D_MODEL] => WORDS_X_FP32
static const uint32_t X_PAGE_WORDS = align_up_words(WORDS_X_FP32, ALIGN_WORDS);

static const uint32_t BASE_X_PING_W = 0;
static const uint32_t SIZE_X_PING_W = X_PAGE_WORDS;

static const uint32_t BASE_X_PONG_W = BASE_X_PING_W + SIZE_X_PING_W;
static const uint32_t SIZE_X_PONG_W = X_PAGE_WORDS;

// Optional aliases with region naming (same values as above)
static const uint32_t X_PAGE0_BASE_W = BASE_X_PING_W;
static const uint32_t X_PAGE0_WORDS  = SIZE_X_PING_W;
static const uint32_t X_PAGE1_BASE_W = BASE_X_PONG_W;
static const uint32_t X_PAGE1_WORDS  = SIZE_X_PONG_W;

// ----------------------------
// SCRATCH (S1: KV cache)
// ----------------------------
// SCR_K: fp32 [N_NODES, D_MODEL]
// SCR_V: fp32 [N_NODES, D_MODEL]
static const uint32_t BASE_SCRATCH_W = BASE_X_PONG_W + SIZE_X_PONG_W;

static const uint32_t BASE_SCR_K_W = align_up_words(BASE_SCRATCH_W, ALIGN_WORDS);
static const uint32_t SIZE_SCR_K_W = X_PAGE_WORDS;

static const uint32_t BASE_SCR_V_W = BASE_SCR_K_W + SIZE_SCR_K_W;
static const uint32_t SIZE_SCR_V_W = X_PAGE_WORDS;

static const uint32_t SIZE_SCRATCH_W = (BASE_SCR_V_W + SIZE_SCR_V_W) - BASE_SCRATCH_W;

// ----------------------------
// [legacy] BIAS region (fp32 words)
// ----------------------------
static const uint32_t BASE_BIAS_W = align_up_words(BASE_SCRATCH_W + SIZE_SCRATCH_W, ALIGN_WORDS);
static const uint32_t SIZE_BIAS_W = align_up_words(EXP_LEN_BIAS_WORDS, ALIGN_WORDS);

// ----------------------------
// [legacy] WEIGHT region
// ----------------------------
// Includes:
// - BCH parity-check H (bitpack) first
// - then model weights (fp32)
// - plus src_mask (bitpack) and other fp32 tensors
static const uint32_t BASE_W_W = BASE_BIAS_W + SIZE_BIAS_W;
static const uint32_t SIZE_W_W = align_up_words(EXP_LEN_W_WORDS, ALIGN_WORDS);

// ----------------------------
// W_REGION (v11.4+ main path)
// ----------------------------
// Unified PARAM stream is written starting at runtime param_base_word.
// SET_W_BASE must range-check param_base_word against this allowed region.
static const uint32_t W_REGION_BASE  = BASE_BIAS_W;
static const uint32_t W_REGION_WORDS = (SIZE_BIAS_W + SIZE_W_W);

// Suggested default for TB bring-up (if no special placement is needed).
static const uint32_t PARAM_BASE_DEFAULT = W_REGION_BASE;

// ----------------------------
// END / sizing
// ----------------------------
static const uint32_t END_W = BASE_W_W + SIZE_W_W;

// Minimum required SRAM depth (words) for this memory map.
static const uint32_t SRAM_WORDS_MIN_REQUIRED = END_W;

// NOTE: Your actual SRAM depth may be larger.
// For TB bring-up, you may set SRAM_WORDS_TOTAL = SRAM_WORDS_MIN_REQUIRED.
static const uint32_t SRAM_WORDS_TOTAL = SRAM_WORDS_MIN_REQUIRED;

// ------------------------------------------------------------
// Region decode helpers (purely by addr_word range)
// ------------------------------------------------------------
static inline bool in_range(uint32_t addr_w, uint32_t base_w, uint32_t size_w) {
  return (addr_w >= base_w) && (addr_w < (base_w + size_w));
}

static inline SramRegion region_of_addr(uint32_t addr_w) {
  if (in_range(addr_w, X_PAGE0_BASE_W, X_PAGE0_WORDS)) return REG_X_PAGE0;
  if (in_range(addr_w, X_PAGE1_BASE_W, X_PAGE1_WORDS)) return REG_X_PAGE1;
  if (in_range(addr_w, BASE_SCRATCH_W, SIZE_SCRATCH_W)) return REG_SCRATCH;
  if (in_range(addr_w, W_REGION_BASE, W_REGION_WORDS)) return REG_W_REGION;
  return REG_INVALID;
}

} // namespace sram_map
