#!/usr/bin/env python3
"""
M16 header generator (single source of truth pipeline entry).

Generates:
  - gen/include/ModelDesc.h
  - gen/include/ModelShapes.h
  - gen/include/SramMap.h
  - gen/include/WeightStreamOrder.h
  - gen/ModelDesc.h                (wrapper)
  - gen/ModelShapes.h              (wrapper)
  - gen/SramMap.h                  (wrapper)
  - gen/WeightStreamOrder.h        (wrapper)
  - gen/manifest.json
"""

from __future__ import annotations

import argparse
import hashlib
import json
import pathlib
import subprocess
import sys
from typing import Dict, List, Tuple


HEADER_NAMES = [
    "ModelDesc.h",
    "ModelShapes.h",
    "SramMap.h",
    "WeightStreamOrder.h",
]


def sha256_text(text: str) -> str:
    return hashlib.sha256(text.encode("utf-8")).hexdigest()


def sha256_bytes(data: bytes) -> str:
    return hashlib.sha256(data).hexdigest()


def normalize_text(text: str) -> str:
    return text.replace("\r\n", "\n").replace("\r", "\n")


def read_text(path: pathlib.Path) -> str:
    return normalize_text(path.read_text(encoding="utf-8"))


def write_text(path: pathlib.Path, text: str) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    path.write_text(text, encoding="utf-8", newline="\n")


def display_path(path: pathlib.Path, repo_root: pathlib.Path) -> str:
    try:
        return str(path.relative_to(repo_root)).replace("\\", "/")
    except ValueError:
        return str(path).replace("\\", "/")


def git_short_hash(repo_root: pathlib.Path) -> str:
    try:
        out = subprocess.check_output(
            ["git", "rev-parse", "--short", "HEAD"],
            cwd=str(repo_root),
            stderr=subprocess.DEVNULL,
            text=True,
        )
        return out.strip()
    except Exception:
        return "nogit"


def transform_header(name: str, text: str) -> str:
    transformed = text
    transformed = transformed.replace('#include "ModelDesc.h"', '#include "gen/ModelDesc.h"')
    transformed = transformed.replace('#include "ModelShapes.h"', '#include "gen/ModelShapes.h"')
    transformed = transformed.replace('#include "SramMap.h"', '#include "gen/SramMap.h"')
    transformed = transformed.replace('#include "WeightStreamOrder.h"', '#include "gen/WeightStreamOrder.h"')

    banner = (
        "// AUTO-GENERATED by tools/gen_headers.py (M16 SSOT pipeline)\n"
        f"// source: include/{name}\n"
        "// DO NOT EDIT THIS FILE MANUALLY.\n\n"
    )
    return banner + transformed


def build_manifest(
    version_tag: str,
    input_items: List[Dict[str, object]],
    output_items: List[Dict[str, object]],
) -> Dict[str, object]:
    concat = "".join(item["sha256"] for item in input_items)  # deterministic
    return {
        "version_tag": version_tag,
        "generator": "tools/gen_headers.py",
        "input_hash": sha256_text(concat),
        "inputs": input_items,
        "outputs": output_items,
        "generated_headers": HEADER_NAMES,
    }


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Generate M16 SSOT headers.")
    parser.add_argument("--repo-root", default=".", help="Repository root path")
    parser.add_argument("--src-include", default="include", help="Source include directory")
    parser.add_argument("--out-root", default="gen", help="Generated root directory")
    parser.add_argument("--version", default="v11.5", help="Spec version tag")
    parser.add_argument(
        "--extra-input",
        action="append",
        default=[],
        help="Additional input artifact path to hash into manifest (repeatable)",
    )
    return parser.parse_args()


def main() -> int:
    args = parse_args()
    repo_root = pathlib.Path(args.repo_root).resolve()
    src_include = (repo_root / args.src_include).resolve()
    out_root = (repo_root / args.out_root).resolve()
    out_include = out_root / "include"

    input_items: List[Dict[str, object]] = []
    output_items: List[Dict[str, object]] = []
    rendered: List[Tuple[str, str]] = []

    for name in HEADER_NAMES:
        src_path = src_include / name
        if not src_path.exists():
            raise FileNotFoundError(f"Missing source header: {src_path}")
        src_text = read_text(src_path)
        input_items.append(
            {
                "path": display_path(src_path, repo_root),
                "sha256": sha256_text(src_text),
                "bytes": len(src_text.encode("utf-8")),
            }
        )
        rendered.append((name, transform_header(name, src_text)))

    for extra in args.extra_input:
        extra_path = (repo_root / extra).resolve()
        if not extra_path.exists():
            continue
        data = extra_path.read_bytes()
        input_items.append(
            {
                "path": display_path(extra_path, repo_root),
                "sha256": sha256_bytes(data),
                "bytes": len(data),
            }
        )

    for name, text in rendered:
        out_path = out_include / name
        write_text(out_path, text)
        data = out_path.read_bytes()
        output_items.append(
            {
                "path": display_path(out_path, repo_root),
                "sha256": sha256_bytes(data),
                "bytes": len(data),
            }
        )

        wrapper_path = out_root / name
        wrapper = (
            "// AUTO-GENERATED wrapper by tools/gen_headers.py (M16)\n"
            "#pragma once\n"
            f'#include "gen/include/{name}"\n'
        )
        write_text(wrapper_path, wrapper)
        wrapper_data = wrapper_path.read_bytes()
        output_items.append(
            {
                "path": display_path(wrapper_path, repo_root),
                "sha256": sha256_bytes(wrapper_data),
                "bytes": len(wrapper_data),
            }
        )

    git_hash = git_short_hash(repo_root)
    version_tag = f"{args.version}+{git_hash}"
    manifest = build_manifest(version_tag, input_items, output_items)
    manifest_path = out_root / "manifest.json"
    write_text(manifest_path, json.dumps(manifest, indent=2, sort_keys=True) + "\n")

    print(f"[gen_headers] generated {len(HEADER_NAMES)} headers into {out_include}")
    print(f"[gen_headers] manifest: {manifest_path}")
    return 0


if __name__ == "__main__":
    sys.exit(main())
